<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/ico" href="https://bitcoin.multipool.dev/favicon.ico">
  <link rel="apple-touch-icon" href="https://bitcoin.multipool.dev/favicon.ico">  
  <link rel="apple-touch-icon" sizes="76x76" href="https://bitcoin.multipool.dev/favicon.ico">
  
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-7VDJYEP1R1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-7VDJYEP1R1');
  </script>
  <title>Crypto Mining Pools & Performance</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!--===============================================================================================-->    
  <link rel="stylesheet" type="text/css" href="vendor/bootstrap/css/bootstrap.min.css">
  <!--===============================================================================================-->
  <link rel="stylesheet" type="text/css" href="fonts/font-awesome-4.7.0/css/font-awesome.min.css">
  <!--===============================================================================================-->
  <link rel="stylesheet" type="text/css" href="vendor/animate/animate.css">
  <!--===============================================================================================-->
  <link rel="stylesheet" type="text/css" href="vendor/select2/select2.min.css">
  <!--===============================================================================================-->
  <link rel="stylesheet" type="text/css" href="vendor/perfect-scrollbar/perfect-scrollbar.css">
  <!--===============================================================================================-->
  <link rel="stylesheet" type="text/css" href="css/util.css">
  <link rel="stylesheet" type="text/css" href="css/main.css">
  <!--===============================================================================================-->
  <style>
    body {
      background: url('images/landscape.png') no-repeat center center fixed;
      background-size: cover;
      min-height: 300vh;
      color: #ffffff;
      margin: 0;
      padding: 0;
    }
    .crypto-icon { width: 24px; height: 24px; margin-right: 5px; vertical-align: middle; }
    .price { color: #28a745; }
    .error { color: #dc3545; }
    .widget-container { margin: 20px 0; }
    h3 { color: #ffffff; text-align: center; margin-bottom: 15px; }
    .table100-head th { 
      background-color: #333; 
      color: #ffffff; 
      padding: 10px; 
    }
    .container { 
      padding-top: 20px;
      min-height: 250vh;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }
    gecko-coin-list-widget { 
      width: 100%; 
      max-width: 600px; 
      margin: 0 auto; 
      display: block; 
    }
    table {
      width: 100%;
      max-width: 1200px;
      margin: 20px auto;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    td, th {
      padding: 10px;
      text-align: left;
    }
    .spacer {
      height: 150vh;
    }
    .fetch-info {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      font-size: 12px;
      z-index: 1000;
    }
    .fetch-info.success { color: #28a745; }
    .fetch-info.error { color: #dc3545; }
    .fetch-info.loading { color: #ffffff; }
  </style>
</head>
<body>
  <!-- Main CoinGecko Marquee Widget at the very top -->
  <script src="https://widgets.coingecko.com/gecko-coin-price-marquee-widget.js"></script>
  <gecko-coin-price-marquee-widget 
    locale="en" 
    dark-mode="true" 
    outlined="true" 
    coin-ids="tether,bitcoin,ethereum,trrxitte,traaitt,traaittxtcash,nyantereum,nyandoge-international,dogecoin,litecoin" 
    initial-currency="usd">
  </gecko-coin-price-marquee-widget>

  <div class="container">
    <!-- General Market Widget -->
    <div class="widget-container">
      <script src="https://widgets.coingecko.com/gecko-coin-list-widget.js"></script>
    </div>

    <!-- SHA-256 and CryptoNote Widgets -->
    <div class="row widget-container">
      <div class="col-md-6">
        <h3>General Market Performance</h3>
        <gecko-coin-list-widget 
          locale="en" 
          dark-mode="true" 
          outlined="true" 
          coin-ids="ethereum,bitcoin,bitcoin-cash,solana,binancecoin" 
          initial-currency="usd">
        </gecko-coin-list-widget>
      </div>
      <div class="col-md-6">
        <h3>TRRXITTE Int. Performance</h3>
        <gecko-coin-list-widget 
          locale="en" 
          dark-mode="true" 
          outlined="true" 
          coin-ids="trrxitte,nyantereum,traaitt,traaittxtcash,nyandoge-international" 
          initial-currency="usd">
        </gecko-coin-list-widget>
      </div>
    </div>

    <!-- SHA-256 and CryptoNote Widgets -->
    <div class="row widget-container">
      <div class="col-md-6">
        <h3>SHA-256 Coins Performance</h3>
        <gecko-coin-list-widget 
          locale="en" 
          dark-mode="true" 
          outlined="true" 
          coin-ids="bitcoin,bitcoin-cash,ecash,bitcoin-cash-sv" 
          initial-currency="usd">
        </gecko-coin-list-widget>
      </div>
      <div class="col-md-6">
        <h3>CryptoNote Coins Performance</h3>
        <gecko-coin-list-widget 
          locale="en" 
          dark-mode="true" 
          outlined="true" 
          coin-ids="monero,dash,zcash,arqma" 
          initial-currency="usd">
        </gecko-coin-list-widget>
      </div>
    </div>
    <br><br><br><br><!-- Mining Stats Table moved below the market widgets -->

    <!-- Image placeholder beneath the table -->
    <div style="width: 100%; text-align: center;">
      <a href="https://bitcoin.multipool.dev/" target="_blank">
        <img src="https://multipool.dev/images/btcportal.png" alt="Mining Stats Image" style="width: 100%; max-width: 100%; height: auto;">
      </a>
    </div>
    <table>
      <thead>
        <tr class="table100-head">
          <th class="column1">Cryptocurrency</th>
          <th class="column2">Price (USD)</th>
          <th class="column3">Mining Pool Url</th>
          <th class="column4">Hashrate</th>
          <th class="column5">Miners</th>
          <th class="column6">Fee</th>
          <th class="column7">Height</th>
          <th class="column8">Last Block</th>
          <th class="column9">Difficulty</th>
          <th class="column10">Tracking</th>
        </tr>
      </thead>
      <tbody id="cryptoTable">
        <!-- Data will be populated dynamically -->
      </tbody>
    </table>

    <!-- Spacer for additional scroll space -->
    <div class="spacer"></div>
  </div>

  <!-- Fetch Info Display -->
  <div id="fetchInfo" class="fetch-info loading">Loading price data...</div>

  <!--===============================================================================================-->    
  <script src="vendor/jquery/jquery-3.2.1.min.js"></script>
  <!--===============================================================================================-->
  <script src="vendor/bootstrap/js/popper.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.min.js"></script>
  <!--===============================================================================================-->
  <script src="vendor/select2/select2.min.js"></script>
  <!--===============================================================================================-->
  <script src="js/main.js"></script>

  <script>
    // Utility function to update fetch info display
    function updateFetchInfo(message, status) {
      const fetchInfo = document.getElementById('fetchInfo');
      fetchInfo.textContent = message;
      fetchInfo.className = `fetch-info ${status}`;
    }

    // Cache handling functions
    function getCachedPrices() {
      const cached = localStorage.getItem('cryptoPrices');
      return cached ? JSON.parse(cached) : null;
    }

    function setCachedPrices(prices) {
      localStorage.setItem('cryptoPrices', JSON.stringify({
        data: prices,
        timestamp: Date.now()
      }));
    }

    // Price formatting function
    function formatPrice(price) {
      if (price === 'N/A' || price === undefined) return '$N/A';
      if (price >= 1) return `$${price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
      if (price >= 0.0001) return `$${price.toFixed(4)}`;
      if (price > 0) return `$${price.toFixed(8)}`;
      return '$0.00000000';
    }

    // Price fetch function with retry logic
    async function fetchPricesWithRetry(coingeckoIds, attempts = 5, delay = 2000) {
      let priceData = {};
      for (let i = 0; i < attempts; i++) {
        try {
          const response = await fetch(
            `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${coingeckoIds}&order=market_cap_desc&per_page=100&page=1&sparkline=false`,
            { headers: { 'Accept': 'application/json' } }
          );
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`CoinGecko API failed: ${response.status} - ${response.statusText} - ${errorText}`);
          }
          const coingeckoData = await response.json();
          if (!Array.isArray(coingeckoData) || coingeckoData.length === 0) {
            throw new Error('Empty or invalid response from CoinGecko');
          }
          coingeckoData.forEach(coin => {
            priceData[coin.id] = {
              price: coin.current_price ?? 'N/A',
              icon: coin.image || ''
            };
          });
          setCachedPrices(priceData);
          updateFetchInfo(`Prices fetched successfully at ${new Date().toLocaleTimeString()}`, 'success');
          return priceData;
        } catch (error) {
          console.warn(`Price fetch attempt ${i + 1}/${attempts} failed: ${error.message}`);
          if (i < attempts - 1) {
            updateFetchInfo(`Retrying price fetch (${i + 1}/${attempts})...`, 'loading');
            await new Promise(resolve => setTimeout(resolve, delay));
          } else {
            console.error('All price fetch attempts failed:', error);
            const cached = getCachedPrices();
            if (cached && (Date.now() - cached.timestamp) < 3600000) { // Use cache if < 1 hour old
              priceData = cached.data;
              updateFetchInfo(`Using cached prices from ${new Date(cached.timestamp).toLocaleTimeString()}`, 'success');
            } else {
              updateFetchInfo('Failed to fetch prices after retries. Using defaults.', 'error');
              priceData['traaitt'] = priceData['traaitt'] || { price: 0.00000001, icon: '' };
              priceData['traaittxtcash'] = priceData['traaittxtcash'] || { price: 0.00000001, icon: '' };
            }
            return priceData;
          }
        }
      }
    }

    // Background price update function
    async function updatePricesInBackground(coingeckoIds) {
      const priceData = await fetchPricesWithRetry(coingeckoIds);
      if (priceData) {
        const rows = document.querySelectorAll('#cryptoTable tr');
        rows.forEach(row => {
          const coingeckoId = row.getAttribute('data-coingecko-id');
          const mergedWith = row.getAttribute('data-merged-with');
          if (coingeckoId) {
            let priceDisplay = formatPrice(priceData[coingeckoId]?.price);
            if (mergedWith && priceData[mergedWith]) {
              priceDisplay += ` / ${formatPrice(priceData[mergedWith]?.price)}`;
            }
            const priceCell = row.querySelector('.price');
            if (priceCell) {
              priceCell.textContent = priceDisplay;
            }
          }
        });
      }
    }

    // Initialize table with default or cached data
    async function initializeTable() {
      updateFetchInfo('Initializing table...', 'loading');
      const tableBody = document.getElementById('cryptoTable');
      tableBody.innerHTML = '<tr><td colspan="10">Loading cryptocurrency data...</td></tr>';

      const pools = [
        { name: 'TRRXITTE XTE', coingeckoId: 'traaitt', logoId: 'xte', poolUrl: 'https://xte.trrxitte.com/api/stats', displayUrl: 'xte.trrxitte.com', linkUrl: 'https://xte.trrxitte.com', tracking: 'Active', isMiningCore: false, defaultFee: '1' },
        { name: 'TRRXITTE XTCASH', coingeckoId: 'traaittxtcash', logoId: 'xtcash', poolUrl: 'https://xtcash.trrxitte.com/api/stats', displayUrl: 'xtcash.trrxitte.com', linkUrl: 'https://xtcash.trrxitte.com', tracking: 'Active', isMiningCore: false, defaultFee: '1' },
        { name: 'Bitcoin', coingeckoId: 'bitcoin', logoId: 'bitcoin', poolId: 'bitcoin', poolUrl: 'https://bitcoin.multipool.dev/api/pools/bitcoin', displayUrl: 'Bitcoin at multipool', linkUrl: 'https://bitcoin.multipool.dev/#bitcoin/connect', tracking: 'Active', isMiningCore: true },
        { name: 'Bitcoin Cash', coingeckoId: 'bitcoin-cash', logoId: 'bitcoincash', poolId: 'bitcoincash', poolUrl: 'https://bitcoin.multipool.dev/api/pools/bitcoincash', displayUrl: 'Bitcoin Cash at multipool', linkUrl: 'https://bitcoin.multipool.dev/#bitcoincash/connect', tracking: 'Active', isMiningCore: true },
        { name: 'Monero', coingeckoId: 'monero', logoId: 'monero', poolId: 'monero', poolUrl: 'https://bitcoin.multipool.dev/api/pools/monero', displayUrl: 'Monero at multipool', linkUrl: 'https://bitcoin.multipool.dev/#monero/connect', tracking: 'Active', isMiningCore: true },
        { name: 'Zcash', coingeckoId: 'zcash', logoId: 'zcash', poolId: 'zcash', poolUrl: 'https://bitcoin.multipool.dev/api/pools/zcash', displayUrl: 'ZCASH at multipool', linkUrl: 'https://bitcoin.multipool.dev/#zcash/connect', tracking: 'Active', isMiningCore: true },
        { name: 'Dash', coingeckoId: 'dash', logoId: 'dash', poolId: 'dash', poolUrl: 'https://bitcoin.multipool.dev/api/pools/dash', displayUrl: 'Dash at multipool', linkUrl: 'https://bitcoin.multipool.dev/#dash/connect', tracking: 'Active', isMiningCore: true },
        { name: 'eCash', coingeckoId: 'ecash', logoId: 'ecash', poolId: 'ecash', poolUrl: 'https://bitcoin.multipool.dev/api/pools/ecash', displayUrl: 'eCash at multipool', linkUrl: 'https://bitcoin.multipool.dev/#ecash/connect', tracking: 'Active', isMiningCore: true },
        { name: 'Bitcoin SV', coingeckoId: 'bitcoin-cash-sv', logoId: 'bitcoinsv', poolId: 'bitcoinsv', poolUrl: 'https://bitcoin.multipool.dev/api/pools/bitcoinsv', displayUrl: 'Bitcoin SV at multipool', linkUrl: 'https://bitcoin.multipool.dev/#bitcoinsv/connect', tracking: 'Active', isMiningCore: true },
        { name: 'Dogecoin + Litecoin', coingeckoId: 'dogecoin', logoId: 'dogecoin', mergedWith: 'litecoin', poolUrl: 'https://doge.multipool.dev/api/pool', displayUrl: 'DOGE + LTC at multipool', linkUrl: 'https://doge.multipool.dev', tracking: 'Active', isMiningCore: false, isDogepool: true, defaultFee: '1' }
      ];

      const multipoolLogos = {
        'bitcoin': 'https://multipool.dev/portal/images/bitcoin.png',
        'bitcoincash': 'https://multipool.dev/portal/images/bitcoincash.png',
        'bitcoinsv': 'https://multipool.dev/portal/images/bitcoinsv.png',
        'dash': 'https://multipool.dev/portal/images/dash.png',
        'dogecoin': 'https://multipool.dev/portal/images/dogecoin.png',
        'ecash': 'https://multipool.dev/portal/images/ecash.png',
        'monero': 'https://multipool.dev/portal/images/monero.png',
        'xtcash': 'https://multipool.dev/portal/images/xtcash.png',
        'xte': 'https://multipool.dev/portal/images/xte.png',
        'zcash': 'https://multipool.dev/portal/images/zcash.png'
      };

      // Load cached prices if available
      let priceData = getCachedPrices()?.data || {};
      const coingeckoIds = [...new Set([...pools.map(pool => pool.coingeckoId), ...pools.filter(p => p.mergedWith).map(p => p.mergedWith)])].join(',');

      // Set default prices for critical coins if not cached
      priceData['traaitt'] = priceData['traaitt'] || { price: 0.00000001, icon: multipoolLogos['xte'] };
      priceData['traaittxtcash'] = priceData['traaittxtcash'] || { price: 0.00000001, icon: multipoolLogos['xtcash'] };

      // Build table immediately with default/cached data
      tableBody.innerHTML = '';
      pools.forEach(pool => {
        const logoUrl = multipoolLogos[pool.logoId] || priceData[pool.coingeckoId]?.icon || '';
        let priceDisplay = formatPrice(priceData[pool.coingeckoId]?.price);
        if (pool.mergedWith) {
          priceDisplay += ` / ${formatPrice(priceData[pool.mergedWith]?.price || 'N/A')}`;
        }

        const row = document.createElement('tr');
        row.setAttribute('data-coingecko-id', pool.coingeckoId);
        if (pool.mergedWith) row.setAttribute('data-merged-with', pool.mergedWith);
        row.innerHTML = `
          <td><img src="${logoUrl}" class="crypto-icon" alt="${pool.name} icon" onerror="this.src='https://multipool.dev/portal/images/default.png'">${pool.name}</td>
          <td class="price">${priceDisplay}</td>
          <td><a href="${pool.linkUrl}">${pool.displayUrl}</a></td>
          <td>Loading...</td>
          <td>Loading...</td>
          <td>${pool.defaultFee || '1'}%</td>
          <td>Loading...</td>
          <td>Loading...</td>
          <td>Loading...</td>
          <td>${pool.tracking}</td>
        `;
        tableBody.appendChild(row);
      });

      // Fetch pool stats and update table
      const poolStats = {};
      for (const pool of pools) {
        try {
          const response = await fetch(pool.poolUrl);
          if (!response.ok) throw new Error(`API failed for ${pool.name}: ${response.status}`);
          const data = await response.json();

          if (pool.isMiningCore) {
            poolStats[pool.coingeckoId] = {
              pool: {
                hashrate: data.pool.poolStats?.poolHashrate || 0,
                miners: data.pool.poolStats?.connectedMiners || 'N/A',
                fee: data.pool.poolFeePercent || pool.defaultFee || '1',
                lastBlock: data.pool.networkStats?.lastNetworkBlockTime ? new Date(data.pool.networkStats.lastNetworkBlockTime).toLocaleString() : 'N/A'
              },
              network: {
                height: data.pool.networkStats?.blockHeight || 'N/A',
                difficulty: data.pool.networkStats?.networkDifficulty || 'N/A'
              }
            };
          } else if (pool.isDogepool) {
            poolStats[pool.coingeckoId] = {
              pool: {
                hashrate: data.hashrate || 0,
                miners: data.miners || 'N/A',
                fee: data.fee || pool.defaultFee || '1',
                lastBlock: data.lastBlock ? new Date(data.lastBlock).toLocaleString() : 'N/A'
              },
              network: {
                height: data.height || 'N/A',
                difficulty: data.difficulty || 'N/A'
              }
            };
          } else {
            poolStats[pool.coingeckoId] = {
              pool: {
                hashrate: data.pool?.hashrate || 0,
                soloHashrate: data.pool?.hashrateSolo || 0,
                miners: data.pool?.miners !== undefined ? data.pool.miners : 'N/A',
                minersSolo: data.pool?.minersSolo !== undefined ? data.pool.minersSolo : 'N/A',
                fee: pool.defaultFee || '1',
                lastBlock: data.pool?.lastBlockFoundSolo 
                  ? new Date(parseInt(data.pool.lastBlockFoundSolo)).toLocaleString() 
                  : data.pool?.lastBlockFoundprop 
                    ? new Date(parseInt(data.pool.lastBlockFoundprop)).toLocaleString() 
                    : 'N/A'
              },
              network: {
                height: data.network?.height || 'N/A',
                difficulty: data.network?.difficulty || 'N/A'
              }
            };
          }
        } catch (error) {
          console.error(`Pool fetch failed for ${pool.name}:`, error);
          poolStats[pool.coingeckoId] = {
            pool: { hashrate: 0, soloHashrate: 0, miners: 'N/A', minersSolo: 'N/A', fee: pool.defaultFee || '1', lastBlock: 'N/A' },
            network: { height: 'N/A', difficulty: 'N/A' }
          };
        }
      }

      // Update table with pool stats
      pools.forEach(pool => {
        const stats = poolStats[pool.coingeckoId];
        const poolStatsData = stats.pool || {};
        const networkStats = stats.network || {};

        const hashrate = poolStatsData.hashrate + (poolStatsData.soloHashrate || 0);
        const miners = poolStatsData.miners === 'N/A' ? 'N/A' : (poolStatsData.miners || 0);
        const minersSolo = poolStatsData.minersSolo === 'N/A' ? 'N/A' : (poolStatsData.minersSolo || 0);
        const totalMiners = (miners === 'N/A' || minersSolo === 'N/A') ? 'none' : (parseInt(miners) + parseInt(minersSolo));
        const minersDisplay = (pool.coingeckoId === 'traaitt' || pool.coingeckoId === 'traaittxtcash') 
          ? `${totalMiners === 'none' ? 'none' : totalMiners + ' total'}` 
          : totalMiners;

        let formattedHashrate = '';
        if (hashrate > 1000000000000) formattedHashrate = (hashrate / 1000000000000).toFixed(2) + ' TH/s';
        else if (hashrate > 1000000000) formattedHashrate = (hashrate / 1000000000).toFixed(2) + ' GH/s';
        else if (hashrate > 1000000) formattedHashrate = (hashrate / 1000000).toFixed(2) + ' MH/s';
        else if (hashrate > 1000) formattedHashrate = (hashrate / 1000).toFixed(2) + ' KH/s';
        else formattedHashrate = hashrate.toFixed(2) + ' H/s';

        let formattedDifficulty = '';
        const difficulty = networkStats.difficulty;
        if (typeof difficulty === 'number') {
          if (difficulty > 1000000000) formattedDifficulty = (difficulty / 1000000000).toFixed(2) + ' G';
          else if (difficulty > 1000000) formattedDifficulty = (difficulty / 1000000).toFixed(2) + ' M';
          else if (difficulty > 1000) formattedDifficulty = (difficulty / 1000).toFixed(2) + ' K';
          else formattedDifficulty = difficulty.toFixed(2);
        } else formattedDifficulty = difficulty;

        const row = tableBody.querySelector(`tr[data-coingecko-id="${pool.coingeckoId}"]`);
        if (row) {
          row.cells[3].textContent = formattedHashrate;
          row.cells[4].textContent = minersDisplay;
          row.cells[5].textContent = `${poolStatsData.fee}%`;
          row.cells[6].textContent = networkStats.height;
          row.cells[7].textContent = poolStatsData.lastBlock;
          row.cells[8].textContent = formattedDifficulty;
        }
      });

      // Start background price updates every 30 seconds
      setInterval(() => updatePricesInBackground(coingeckoIds), 30000);

      // Initial price fetch in background
      updatePricesInBackground(coingeckoIds);
    }

    // Run initialization
    initializeTable();
  </script>
</body>
</html>